/* eslint no-use-before-define: ["error", { "functions": false }] */

import uuid from 'uuid';
import {first} from 'rxjs/operators';

import {constructCallObject} from './helpers';

export const UPDATE_STATUS = 'media/UPDATE_STATUS';

export const DISMISS_INCOMING_CALL = 'media/DISMISS_INCOMING_CALL';
export const ANSWERED_INCOMING_CALL = 'media/ANSWERED_INCOMING_CALL';
export const STORE_CALL = 'media/STORE_CALL';
export const UPDATE_CALL_STATUS = 'media/UPDATE_CALL_STATUS';
export const UPDATE_CALL_ERROR = 'media/UPDATE_CALL_ERROR';
export const REMOVE_CALL = 'media/REMOVE_CALL';

export const CHECKING_WEB_RTC_SUPPORT = 'media/CHECKING_WEB_RTC_SUPPORT';
export const UPDATE_WEBRTC_SUPPORT = 'media/UPDATE_WEBRTC_SUPPORT';

const tap = (promise) => (arg) => Promise.resolve()
  .then(promise(arg))
  .then(() => arg);

/* Actions */

function answeredIncomingCall(callId) {
  return {
    type: ANSWERED_INCOMING_CALL,
    payload: {
      id: callId
    }
  };
}

function checkingWebRTCSupport() {
  return {
    type: CHECKING_WEB_RTC_SUPPORT
  };
}

function removeCall(id) {
  return {
    type: REMOVE_CALL,
    payload: {
      id
    }
  };
}

export function storeCall({call, id, destination}) {
  // check if this is a locus replaced call
  return {
    type: STORE_CALL,
    payload: {
      id,
      call: constructCallObject(call),
      destination
    }
  };
}

function updateCallError({call, error, id}) {
  return {
    type: UPDATE_CALL_ERROR,
    payload: {
      id: id || call.id,
      call: constructCallObject(call),
      error
    }
  };
}

function updateCallStatus({call, id, eventName}) {
  return {
    type: UPDATE_CALL_STATUS,
    payload: {
      id,
      call: constructCallObject(call),
      eventName
    }
  };
}

function updateStatus(status) {
  return {
    type: UPDATE_STATUS,
    payload: {
      status
    }
  };
}

function updateWebRTCSupport(supported) {
  return {
    type: UPDATE_WEBRTC_SUPPORT,
    payload: {
      supported
    }
  };
}

const findExistingMeeting = (meetings) => ({type, destination}) => {
  const meetingProp = (() => {
    switch (type) {
      case 'CONVERSATION_URL':
        return 'convoUrl';
      default:
        return 'locusUrl';
    }
  })();

  return meetings.getMeetingByType(meetingProp, destination);
};

/* Exported Actions */

/**
 * Accepts an incoming call
 *
 * @export
 * @param {object} incomingCall
 * @returns {Promise}
 */
export function acceptIncomingCall(incomingCall, {sdkAdapter, destinationId, cleanUp}) {
  return (dispatch) => {
    const {meetingsAdapter} = sdkAdapter;

    return Promise.resolve()
      .then(() => meetingsAdapter.datasource.meetings.getMeetingByType('locusUrl', incomingCall.locusUrl))
      .then((meeting) => {
        const bye = meeting.leave;

        meeting.leave = (...args) => bye.bind(meeting)(...args)
          .then(() => dispatch(removeCall(incomingCall.id)))
          .then(() => dispatch(cleanUp()))
          .finally(() => { meeting.leave = bye.bind(meeting); });

        return meeting;
      })
      .then((meeting) => meetingsAdapter.getLocalMedia(meeting.id)
        .then(({localAudio, localVideo}) => meetingsAdapter.fetchMeetingTitle(destinationId)
          .then((title) => {
            meetingsAdapter.meetings[meeting.id] = {
              ID: meeting.id,
              title,
              localAudio,
              localVideo,
              localShare: null,
              remoteAudio: null,
              remoteVideo: null,
              remoteShare: null
            };

            return meeting;
          })))
      .then(tap((meeting) => {
        processCall({dispatch, call: {...meeting}, destinationId});
      }))
      .then(tap((meeting) => dispatch(updateCallStatus({
        call: {
          ...meeting,
          hasJoinedOnThisDevice: true
        },
        id: meeting.id
      }))))
      .then(tap((meeting) => meetingsAdapter.joinMeeting(meeting.id)))
      .catch((err) => console.error('*******', err));
  };
}

/**
 * Does a spark API request for existing calls and stores them
 * @param {object} sparkInstance
 * @returns {Promise}
 */
export function checkCurrentCalls(sparkInstance) {
  return (dispatch) => sparkInstance.phone.listActiveCalls()
    .then((results) => Promise.all(results.map((callObject) =>
      Promise.resolve(processCall({dispatch, call: callObject})))));
}

/**
 * Check for browser webRTC support
 *
 *  @param {object} sparkInstance
 *  @returns {Promise}
 */
export function checkWebRTCSupport(sparkInstance) {
  return (dispatch) => {
    if (sparkInstance.phone) {
      dispatch(checkingWebRTCSupport());

      return sparkInstance.phone.isCallingSupported()
        .then((supported) => dispatch(updateWebRTCSupport(supported)));
    }

    return Promise.resolve();
  };
}

/**
 * Declines an incoming call
 *
 * @export
 * @param {object} incomingCall
 * @returns {Thunk}
 */
export function declineIncomingCall(incomingCall, {meetingsAdapter}) {
  const {meetings} = meetingsAdapter.datasource;

  return (dispatch) => {
    meetings.getMeetingByType('id', incomingCall.id).decline();
    dispatch(removeCall(incomingCall.id));

    return Promise.resolve();
  };
}

/**
 * Dismisses an incoming call, marking it so.
 * Note: This does not decline the call, just for tracking purposes
 * @param {string} id
 * @returns {object}
 */
export function dismissIncomingCall(id) {
  return {
    type: DISMISS_INCOMING_CALL,
    payload: {
      id
    }
  };
}

/**
 * Hangs up and removes call
 * @param {object} call
 * @returns {Promise}
 */
export function hangupCall({call, id}) {
  return (dispatch) => {
    // Don't update call states after hangup
    call.off();

    // Only call.hangup() when local user wants to hangup.
    // SDK handles .hangup() when call becomes `inactive`
    return call.hangup()
      .then(() => dispatch(removeCall(id)))
      .catch(() => dispatch(removeCall(id)));
  };
}

/**
 * Listens for all call events from phone plugin and handles them
 * @param {Object} sparkInstance
 * @returns {Promise}
 */
export function listenForCalls(sparkInstance) {
  return (dispatch) => {
    dispatch(updateStatus({isListening: true, isListeningToIncoming: true}));

    return Promise.all([
      handleIncomingCalls(sparkInstance),
      handleCreatedCalls(sparkInstance, dispatch)
    ]);
  };
}

/**
 * Checks if the machine has at least one audio or video device
 * @returns {Promise.<Object>} {
 *    audio: true/false,
 *    video: true/false
 *}
 */
function getSupportedDevice() {
  return Promise.resolve().then(() => {
    if (!navigator.mediaDevices || navigator.mediaDevices.enumerateDevices === undefined) {
      return {
        audio: false,
        video: false
      };
    }

    // Reference for device.kind: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices
    return navigator.mediaDevices.enumerateDevices()
      .then((devices) => ({
        audio: devices.filter((device) => device.kind === 'audioinput').length > 0,
        video: devices.filter((device) => device.kind === 'videoinput').length > 0
      }));
  });
}

let meetingPromise;
const getMeeting = ({sdkAdapter: {meetingsAdapter}, destination}) => {
  if (!meetingPromise) {
    meetingPromise = new Promise((resolve) => {
      meetingsAdapter.createMeeting(destination)
        .pipe(first())
        .subscribe(({ID}) =>
          resolve(meetingsAdapter.datasource.meetings.getMeetingByType('id', ID)));
    });

    return meetingPromise;
  }

  return meetingPromise
    .then(tap((meeting) => meetingsAdapter.datasource.meetings.meetingCollection.set(meeting)))
    .then((meeting) => meetingsAdapter.getLocalMedia(meeting.id)
      .then(({localAudio, localVideo}) => meetingsAdapter.fetchMeetingTitle(destination)
        .then((title) => {
          meetingsAdapter.meetings[meeting.id] = {
            ID: meeting.id,
            title,
            localAudio,
            localVideo,
            localShare: null,
            remoteAudio: null,
            remoteVideo: null,
            remoteShare: null
          };

          return meeting;
        })));
};

/**
 * Call a user with an email address or userId
 *
 * @export
 * @param {Object} sdkAdapter
 * @param {String} data.destination
 * @returns {Promise}
 */
export function placeCall(sdkAdapter, {destination, cleanUp}) {
  const {meetingsAdapter} = sdkAdapter;

  return (dispatch) => getMeeting({sdkAdapter, destination})
    .then(tap((meeting) => processCall({dispatch, call: {...meeting}, destination})))
    .then((meeting) => {
      const bye = meeting.leave;

      meeting.leave = (...args) => bye.bind(meeting)(...args)
        .then(() => dispatch(removeCall(meeting.id)))
        .then(() => dispatch(cleanUp()))
        .finally(() => { meeting.leave = bye.bind(meeting); });

      return meeting;
    })
    .then(tap((meeting) => meetingsAdapter.joinMeeting(meeting.id)));
}
/*
export function placeCall(sdkAdapter, {destination, cleanUp}) {
  const {meetingsAdapter} = sdkAdapter;

  return (dispatch) => meetingsAdapter.datasource.meetings.meetingInfo.fetchInfoOptions(destination)
    .then(findExistingMeeting(meetingsAdapter.datasource.meetings))
    .then((existingMeeting) => {
      if (existingMeeting) {
        return acceptIncomingCall(existingMeeting, {sdkAdapter, destinationId: destination, cleanUp})(dispatch);
      }

      return new Promise((resolve) => {
        meetingsAdapter.createMeeting(destination)
          .pipe(first())
          .subscribe((call) => Promise.resolve()
            .then(() => meetingsAdapter.datasource.meetings.getMeetingByType('id', call.ID))
            .then((meeting) => {
              processCall({dispatch, call: {...meeting}, destination});

              return meeting;
            })
            .then((meeting) => {
              const bye = meeting.leave;

              meeting.leave = (...args) => bye.bind(meeting)(...args)
                .then(() => dispatch(removeCall(meeting.id)))
                .then(() => dispatch(cleanUp()))
                .finally(() => { meeting.leave = bye.bind(meeting); });

              return meeting;
            })
            .then((meeting) => meetingsAdapter.joinMeeting(meeting.id)
              .then(() => resolve(meeting))));
      });
    });
}
*/

/**
 * Registers the client for media/phone
 * @param {object} sparkInstance
 * @returns {Promise}
 */
export function registerClient(sparkInstance) {
  return (dispatch, getState) => {
    const {media} = getState();

    if (!media.status.isRegistered && !media.status.isRegistering) {
      dispatch(updateStatus({isRegistering: true}));

      return sparkInstance.phone.register().then(() => {
        const status = {isRegistered: true, isRegistering: false};

        dispatch(updateStatus(status));

        return status;
      });
    }

    return Promise.resolve(media.status);
  };
}

/**
 * Process and store a call object from outside widgets
 * @param {Object} call
 * @returns {Function}
 */
export function storeExternalCall(call) {
  return (dispatch) => {
    const {id} = processCall({dispatch, call});

    return {id, call};
  };
}


/* Helper Functions */

/**
 * Binds call events and dispatches to store
 * @param {*} params.dispatch
 * @param {Object} params.call
 * @param {String} params.id
 * @returns {Object} {call, id}
 */
function bindEvents({dispatch, call, id}) {
  const callId = id || uuid.v4();

  const updateCall = (callInstance, eventName) =>
    dispatch(updateCallStatus({
      call: callInstance,
      id: callId,
      eventName
    }));

  call.once('active', () => dispatch(updateCall(call, 'active')));
  call.once('inactive', () => dispatch(removeCall(callId)));

  [
    'change:state',
    'change:sendingAudio',
    'change:receivingAudio',
    'change:sendingVideo',
    'change:receivingVideo',
    'change:activeParticipantsCount',
    'remoteAudioMuted:change',
    'remoteVideoMuted:change',
    'remoteMediaStream:change',
    'localMediaStream:change',
    'change:joinedOnThisDevice',
    'membership:notified',
    'membership:disconnected',
    'membership:change',
    'memberships:add',
    'memberships:remove'
  ].map((event) => call.on(event, () => updateCall(call, event)));

  if (call.direction === 'out') {
    // If we rejected the call elsewhere, remove it
    call.on('membership:declined', () => {
      if (call.me.state === 'rejected') {
        dispatch(dismissIncomingCall(callId));
      }
    });

    call.on('membership:change', () => {
      // Once we are connected, our connected call state will handle disconnects
      if (call.me.state === 'connected') {
        dispatch(answeredIncomingCall(callId));
        // incomingCall.joinedOnThisDevice takes a few ticks so we have to
        // calculate it ourselves for now
        if (call.locus.self.deviceUrl !== call.webex.internal.device.url) {
          // We are not connected on this device, dismiss
          dispatch(dismissIncomingCall(callId));
        }
      }
    });
  }

  call.on('membership:declined', () => {
    if (call.isCall && call.remoteMember && call.remoteMember.state === 'declined') {
      // Hang up if the remote person declines the call
      return dispatch(hangupCall({call, id: callId}));
    }
    if (call.me.state === 'rejected') {
      dispatch(dismissIncomingCall(callId));
    }

    return updateCall(call, 'membership:declined');
  });
  call.on('error', (error) => dispatch(updateCallError({call, error, id: call.id || callId})));

  return {call, id: callId};
}

/**
 * Processes a call by binding events and storing
 * @param {*} params.dispatch
 * @param {Object} params.meeting
 * @returns {Object} {id, call}
 */
function processCall({dispatch, call, destination}) {
  const value = {call, id: call.id, destination};

  dispatch(storeCall(value));

  return value;
}

/**
 * Sets up event listener for the 'call:incoming' phone event
 * @param {object} sparkInstance
 * @param {object} dispatch
 * @returns {Promise}
 */
function handleIncomingCalls(sparkInstance) {
  return sparkInstance.phone.on('call:incoming', (incomingCall) => {
    // If we make an outbound call via the widget, when the remote party answers,
    // we get a call:incoming notification when they connect
    if (incomingCall.direction === 'out') {
      return false;
    }

    return incomingCall.acknowledge();
  });
}

/**
 * Sets up event listener for the 'call:created' phone event
 * @param {object} sparkInstance
 * @param {object} dispatch
 * @returns {Promise}
 */
function handleCreatedCalls(sparkInstance, dispatch) {
  sparkInstance.meetings.on('meeting:added', ({meeting, type}) => {
    console.log(type, meeting);
    if (type === 'JOIN') {
      const call = {
        ...meeting,
        direction: 'in',
        hasJoinedOnThisDevice: false
      };

      processCall({dispatch, call});
    }
  });

  return Promise.resolve();
}
